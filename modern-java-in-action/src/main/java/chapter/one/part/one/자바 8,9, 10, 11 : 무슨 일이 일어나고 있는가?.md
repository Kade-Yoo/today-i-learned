# 자바 8, 9, 10, 11 : 무슨일이 일어나고 있는가?

## 1.1 역사의 흐름은 무엇인가?
- 생산성을 높이기 위한 기능 제공
- 멀티 코어 환경에서 유후자원까지 사용하는 흐름
## 1.2 왜 아직도 자바는 변화하는가?
- 새로운 언어가 등장함에 따라 기존에 변화하지 않는 언어는 사장되는게 현실이었다.
### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치
- 자바의 출발은 좋았다.
- 강점인 안정성, 코드를 JVM을 이용해 바이트 코드로 컴파일하여 어느 브라우저에서나 지원이 가능했다는 점
- 또 최근 들어서는 빅데이터(테라바이트 이상의 데이터셋)라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다. -> 이부분은 자바가 변화가 필요했던 부분
### 1.2.2 스트림 처리
- 변화에 바람이 불어 옴에 따라 자바는 첫번째 변신을 했다.
- 그것은 바로 스트림 처리이다.
- 여기서 스트림이란 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임
- 글로 표현되어있는 말이 아직 이해가 잘되지 않는다.
- 자바의 스트림 API는 파이프라인을 만드는 데 많은 메서드를 제공하고 있다.
- 여기서 파이프라인이랑 데이터 출력을 다음 입력으로 받아서 연속적으로 기능을 수행하는 것이라고 보면된다.
- 이런 스트림 API 파이프라인의 강점은 사람이 이해하기 쉽게 바꿨다는 것이다. (예를 들어 주면 좋아 보임)
- 또한 파이프라인을 통해 멀티 코어 CPU에 할당할 수 있다는 점도 추가 되었다.
### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기
- 동작 파라미터화란 메소드 파라미터로 코드(Behavior)를 전달하는 것이다.
```
    /**
     * Java8 이전 정렬 로직으로 구현한 CustomerId 조회
     * @return 정렬된 CustomerId
     */
    public List<String> getCustomerIdBySortBeforeJava8() {
        customerIds.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.compareTo(o2);
            }
        });
    
        return customerIds;
    }
```
---------------------------------------------------------
```
    /**
     * Java8 이후 정렬 로직으로 구현한 CustomerId 조회
     * @return 정렬된 CustomerId
     */
    public List<String> getCustomerIdBySortAfterJava8() {
        customerIds.sort(Comparator.comparing(String::new));
        return customerIds;
    }
```
### 1.2.4 병렬성과 공유 가변 데이터
- 병렬성을 공짜로 얻을 수 있다.
- 스트림 메서드로 전달하는 코드는 다른코드와 동시에 실행하더라도 안전하게 실행된다.
- 공유된 변수나 객체가 있으면 병렬성이 문제가 발생한다.
- pure function, side-effect-free function, stateless function
### 1.2.5 자바가 진화해야 하는 이유
- 어떤 문제를 더 효율적으로 해결하기 위해 자바가 진화해야 한다.