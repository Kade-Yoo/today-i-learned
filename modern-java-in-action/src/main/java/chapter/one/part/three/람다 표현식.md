# 3. 람다 표현식
- 람다 표현식으로 인해 더 간결하고 유연한 코드 구현을 할 수 있다.
## 3.1 람다란 무엇인가?
- 람다 표현식은 메소드로 전달할 수 있는 익명 함수를 단순화한 것
- 람다의 특징으로는 4가지가 있다.
- 익명 : 이름이 없는 메소드이므로 익명이라고 한다.
- 함수 : 메소드처럼 특정 클래스에 종속되는 것이 아니지만, 메소드처럼 바디, 파라미터, 반환 형식, 가능한 예외 리스트를 포함한다.
- 전달 : 람다 표현식을 인수로 저장하거나 파라미터로 전달할 수 있다.
- 간결성 : 익명 클래스처럼 불필요한 코드를 구현하지 않아도 된다.
- 람다 표현식은 파라미터, 화살표, 람다 바디로 이루어진다.
- 람다 문법 
  - (parameters) -> expression
  - (parameters) -> { statements; }
  - expression과 statements의 차이는 키워드 존재 유무이다.
  - expression은 하나의 값으로 반환을 할 수 있는 수식이고,
  - statements는 하나 이상의 expression과 키워드를 합쳐서 짜여진 코드 블록이다.
## 3.2 어디에, 어떻게 람다를 사용할까?
- 함수형 인터페이스라는 문맥에서 람다 표현식을 사용할 수 있다.
### 3.2.1 함수형 인터페이스
- 함수형 인터페이스는 하나의 추상 메소드를 지정하는 인터페이스
- 람다 전체 표현식을 함수형 인터페이스의 인스턴스로 취급(기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스)
### 3.2.2 함수 디스크립터
- 메소드 시그니처는 오버라이딩할 때 필요한 <strong>네임과 파라미터 리스트</strong>이다.
- 함수는 추상 메소드 시그니처를 갖고 있고 이 추상 메소드 <strong>시그니처를 서술하는 것을 함수 디스크립터(Descriptor)</strong>라고 한다.
- 함수 디스크립터의 예외 중 하나는 반환 값이 void타입일 때 statements라도 {}를 표시하지 않아도 된다는 것이다.
- 이유는 반환 값이 있는 것이 expression인데 void타입이라 반환값이 없기 때문에 {}를 생략할 수 있는 것 같다.
## 3.3 람다 활용 : 실행 어라운드 패턴
- 자원을 처리하는 코드를 설정과 정리 두 과정으로 감싸는 것을 실행 어라운드 패턴이라고 한다.
- 근데 실행 어라운드 패턴을 왜 사용하는지 이해하지 못했다.
```
/**
* 실행 어라운드 패턴에 필요한 예제
* 
* @return 파일에서 읽은 내용 한줄
*/
public static String processFile() throws IOException {
  try (BufferedReader br = new BufferedReader(new FileReader(""))) {
    return br.readLine();
  }
}
```
### 3.3.1 1단계 : 동작 파라미터화를 기억하라.
- 위 예제를 바탕으로 한줄 읽는 내용을 파라미터화 시키려고 한다.
```
String readLineStr = Lambda.processFile((BufferedReader br) -> br.readLine());
```
### 3.3.2 2단계 : 함수형 인터페이스를 이용해서 동작 전달
- @FunctionalInterface를 사용하여 함수형 인터페이스로 정의
```
/**
 * 동작 파라미터화
 *
 * @return 파일에서 읽은 내용 한줄
 * @throws IOException
 */
public static String processFile(BefferedReaderProcessor brp) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(""))) {
        return brp.process(br);
    }
}

@FunctionalInterface
public interface BefferedReaderProcessor {
    String process(BufferedReader br) throws IOException;
}
```
### 3.3.3 3단계 : 동작 실행
```
- brp.precess(br)을 통해 처리한다
/**
 * 동작 파라미터화
 *
 * @return 파일에서 읽은 내용 한줄
 * @throws IOException
 */
public static String processFile(BefferedReaderProcessor brp) throws IOException {
    try (BufferedReader br = new BufferedReader(new FileReader(""))) {
        return brp.process(br);
    }
}
```
### 3.3.4 4단계 : 람다 전달
```
String readLineStr = Lambda.processFile((BufferedReader br) -> br.readLine() + br.readLine());
```
## 3.4 함수형 인터페이스 사용
- java.util.function 패키지에 java에서 제공하는 함수형 인터페이스가 있다.
### 3.4.1 Predicate
- Predicate<T> 인터페이스는 test라는 추상 메소드를 호출하여 boolean값을 반환한다.
- 주로 활용되고 있는 곳은 Stream, Matcher등이 있다.
```
/**
 * Predicate
 * 
 * 활용 방안
 * - 같은 리스트에서 다른 조건으로 필터링을 하고 싶을 때
 * 사용처
 * - stream.filter
 * - stream.anyMatch
 */
public static boolean testPredicate() {
    Predicate<String> predicate = String::isEmpty;
    Predicate<String> or = predicate.or(String::isEmpty);
    return predicate.or(or).or(or).or(or).test("");
}
```
### 3.4.2 Consumer
- Consumer<T> 인터페이스는 accept라는 추상 메소드를 호출하여 void를 반환한다.
- 주로 활용되고 있는 곳은 Stream, ArrayList, List등이 있다.
```
/**
 * Consumer
 * 
 * 활용 방안
 * - 루프를 돌면서 각 엘리먼트 별로 다른 set을 적용하고 싶을 때
 * - 서로 다른 print를 찍어주고 싶을 떄
 * - 서로 다른 log를 찍어주고 싶을 때
 * 사용처
 * - stream.forEach
 * - ArrayList
 * - Iterator
 */
public static void acceptConsumer() {
    Consumer<String> consumer = (String str) -> System.out.println(str.toLowerCase());
    consumer.accept("Test");
}
```
### 3.4.3 Function
- Function<T, R> 인터페이스는 apply라는 추상 메소드를 호출하여 R을 반환한다.
- 주로 활용되고 있는 곳은 Stream 등이 있다.
```
/**
 * Function
 * 
 * 활용 방안
 * - A to B로 변환할 때
 */
public static void applyFunction() {
    Function<String, String> stringStringFunction = (String str) -> str.toLowerCase();
    stringStringFunction.apply("TesTTTTe");
}
```

### Supplier
- Supplier<T> 인터페이스는 get이라는 추상 메소드를 호출하여 T를 반환한다.
- AssertEquals에서 Message를 반환한다.

#### 주요 함수형 인터페이스
- Predicate, Consumer, Function, Supplier, UnaryOperator, BinaryOperator
- BiPredicate, BiConsumer, BiFunction
- IntFunction, IntPredicate, IntSupplier

## 3.5 형식 검사, 형식 추론, 제약
### 3.5.1 형식 검사